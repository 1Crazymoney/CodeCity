#!/usr/bin/perl

# Copyright 2017 Google Inc.
# https://github.com/NeilFraser/CodeCity
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# Instructions:
#
# Fetch https://github.com/estree/estree/blob/master/es5.md to es5.md
#
# ./md2go es5.md > astnodes.go
#

use strict;
use feature "switch";
use warnings;
no warnings "experimental";

use Data::Dumper;
use Text::Wrap;

# For comment wrapping:
$Text::Wrap::columns = 70;

# Treat these specially; they get split into:
# - foo: interface type satisfied by several other node types;
# - Foo: struct wrapper for unmarshaling just one foo
# - Foos: struct wrapper for unmarshaling slice of foo
my @interfaces = qw(Node Statement Expression);

# Some node types are just replaced by "stuff" structs; this includes
# all @interfaces (whose stuff structs might have no data but do
# impement _is_type() methods to satisfy the corresponding interface):
my @stuff = (@interfaces, qw(Function));

# Ignore these types; they are never produced by Acorn:
my @ignore = qw(Pattern Declaration RegExpLiteral);

# Patch these structure type declarations, as either Acorn produces
# something different from the spec or we need to handle it specially:
my %field_patches = (
    "UpdateExpression.Operator"     => "string",
    "BinaryExpression.Operator"     => "string",
    "UnaryExpression.Operator"      => "string",
    "AssignmentExpression.Operator" => "string",
    "LogicalExpression.Operator"    => "string",
    "ForStatement.Init"             => "ForStatementInit",
    "ForInStatement.Left"           => "LValue",
    "AssignmentExpression.Left"     => "LValue",
    "UpdateExpression.Argument"     => "LValue",
    "functionStuff.Params"          => "*Identifier",
    "VariableDeclarator.Id"         => "*Identifier",
    "CatchClause.Param"             => "*Identifier",
    "Property.Key"                  => "PropertyKey",
    "Literal.Value"                 => undef,
    );

# Patch these structure type declarations and associated entries in
# %implementations as we don't care about certain intermediate
# abstract interfaces (e.g., all Declarations are just Statements as
# far as we are concerned):
my %parent_patches = (
    "Function" => [],
    "FunctionDeclaration" => ["Statement", "Function"],
    "VariableDeclaration" => ["Statement"],
    );

# Extra fields returned by Acorn not mentioned in spec:
my %extras = (
    "Node" => [['Start', 'int', 'json:"start"'],
	       ['End', 'int', 'json:"end"']],
    "Literal" => [["Raw", "string", 'json:"raw,omitempty"']],
    "VariableDeclaration" => [["Kind", "string", 'json:"kind,omitempty"']],
    );
	       


print "// AUTO-GENERATED BY md2go.  DO NOT EDIT.\n\n";
print "package ast\n\n";

# Per-type data:
my($type, $name, $comments) = ("", "", "");
my(@fields, @parents);

# Data accumulated through whole input file:
my(%implementations, %children);
    
while(<>) {
    # Skip table of contents:
    next if 1../END doctoc/;

    # Look for the ```-quoted blocks:
    if (/^```js$/../^```$/) {
	# Is this the first line of an interface declaration?  If so
	# get type, parents.
	if(/interface\s+(\w+)(?:\s*<:\s*(.*?))?\s*{/) {
	    $type = $1;
	    $name = $1;
	    # Is type actually going to be an interface?  Create
	    # common-stuff struct instead:
	    if($type ~~ @stuff) {
		$type = lcfirst($type) . "Stuff"
	    }

	    # Does it have superclass(es)?
	    if($parent_patches{$name}) {
		@parents = @{$parent_patches{$name}}
	    }
	    elsif($2) {
		@parents = grep { !($_ ~~ @ignore) } split(/\s*,\s*/, $2);
	    }
	    for my $p (@parents) {
		# Record original heirarchy:
		$children{$p} ||= [];
		push(@{$children{$p}}, $name);

		unless($name ~~ @stuff || $name ~~ @ignore) {
		    # Record implementations:
		    if($p ~~ @interfaces) {
			$implementations{$p} ||= [];
			push(@{$implementations{$p}}, $name);
		    }
		}
		
		# Is parent type actually an interface other type that
		# has been replaced by embedded "Stuff" struct?
		if($p ~~ @stuff) {
		    $p = lcfirst($p) . "Stuff"
		}
	    }
	}
	# Does this declare properties?
	elsif(/^\s*(\w+):\s*(.*?)\s*;/) {
	    my($field, $ftype, $pfx, $json) = (ucfirst($1), $2, "", $1);
	    next if $ftype =~ /\"/;  # Ignore Type constants
	    $pfx = "[]" if $ftype =~ s/\[\s*(.*?)\s*\]/$1/;
	    $ftype =~ s/\s*\|\s*null\s*//;
	    given($ftype) {
		# Use Go types for corresponding JS types:
		when(/^boolean$/) { $ftype = "bool"; }
		when(/^string$/) { $ftype = "string"; $json .= ",omitempty" }
		when(/^number$/) { $ftype = "int"; } # line/col/position only

		default {
		    # Interfaces get special treatment:
		    if($ftype ~~ @interfaces) {
			if($pfx) {
			    $pfx = "";
			    $ftype .= "s"
			}
		    }
		    # Normal child nodes are pointed at:
		    else {
			$ftype = "*$_" 
		    }
		    # Patch certain entries as required:
		    if(exists $field_patches{"$type.$field"}) {
			if(defined($field_patches{"$type.$field"})) {
			    $ftype = $field_patches{"$type.$field"};
			}
			else {
			    warn("Ignoring: $type.$field\n");
			    $field = undef;			    # Skip
			}
		    }
		    $json .= ",omitempty";
		}
	    }
	    push @fields, [$field, $pfx . $ftype, "json:\"$json\""]
		if $field;
	}
	else {
	    warn("Ignoring: ", $_) unless /^```|^}/;
	}
    }
    elsif($_ !~ /^$/ && !/^#/) {
	# Discussion?  Save as comment.
	s/^A(?=n? )/$type is a/;
     	s/`//g;
	$comments .= "//\n" if $comments;
	$comments .= wrap("// ", "// ", $_);
    }

    # Start of next section or net declaration; generate code & reset:
    if(/^#/ || /^```js/) {
	if($name ~~ @ignore) {
	    warn "Ignoring: whole declaration of $name\n";
	}
	elsif($name) {
	    print "/" . ("*" x 68) . "/\n\n";
	    print $comments;
	    print "// (Auto-generated from ESTree spec.)\n" if $comments;
	    print "type $type struct {\n";
	    foreach my $p (@parents) {
		print "\t$p\n"
	    }
	    foreach my $f (@fields, @{$extras{$name}}) {
		print "\t", $$f[0], "\t", $$f[1];
		print "\t`", $$f[2], "`" if $$f[2];
		print "\n";
	    }
	    print "}\n\n";
	    
	    # print "func ($type) Type() {\n";
	    # print "\treturn \"$name\"\n";
	    # print "}\n\n";
	}
	
	$type = $name = $comments = "";
	@fields = @parents = ();
    }
}

print "/" . ("*" x 68) . "/\n\n";

# Maps from type name to nil value of type, for types satisfying each
# interface:
foreach my $i (@interfaces) {
    my $int = lcfirst($i);
    print "var ${int}Types = map[string]${int}{\n";
    foreach my $t (@{$implementations{$i}}) {
	print "\t\"$t\": (*$t)(nil),\n"
    }
    print "}\n\n";
}
	
$Data::Dumper::Sortkeys = 1;
print "// $_" foreach split(/^/m, Dumper(\%children));
