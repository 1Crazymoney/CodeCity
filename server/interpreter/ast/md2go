#!/usr/bin/perl

use strict;
use feature "switch";
use warnings;
no warnings "experimental";

use Data::Dumper;
use Text::Wrap;

$Text::Wrap::columns = 70;

# Treat these specially; they get split into:
# - foo: interface type satisfied by several other node types;
# - Foo: struct wrapper for unmarshaling just one foo
# - Foos: struct wrapper for unmarshaling slice of foo
#
my @interfaces = qw(Node Statement Expression);

# Ignore these types; they are never produced by Acorn:
my @ignore = qw(Pattern RegExpLiteral);

# Patch these structure type declarations, as either Acorn produces
# something different from the spec or we need to handle it specially:
my %patches = (
    "UpdateExpression.Operator"     => "string",
    "BinaryExpression.Operator"     => "string",
    "AssignmentExpression.Operator" => "string",
    "LogicalExpression.Operator"    => "string",
    "ForStatement.Init"             => "DeclOrExp",
    "ForInStatement.Left"           => "DeclOrExp",
    "Function.Params"               => "Identifier",
    "VariableDeclarator.Id"         => "Identifier",
    "CatchClause.Param"             => "Identifier",
    "AssignmentExpression.Left"     => "Expression",
    );

print "// AUTO-GENERATED BY md2go.  DO NOT EDIT.\n\n";

my($type, $name, @fields, @parents, %children, $comments);
    
while(<>) {
    # Skip table of contents:
    next if 1../END doctoc/;
    
    if (/^```js$/../^```$/) {
	# Is this the first line of declaration?  If so get type, parents
	if(/interface\s+(\w+)(?:\s*<:\s*(.*?))?\s*{/) {
	    $type = "$1";
	    # Declarations are just statements:
	    $type =~ s/.*Declaration$/Statement/;
	    $name = $1;
	    # Is type actually going to be an interface?  Create
	    # common-stuff struct instead:
	    if($type ~~ @interfaces) {
		$type = lcfirst($type) . "Stuff"
	    }
	    # Does it have superclass(es)?
	    if($2) {
		@parents = grep { !($_ ~~ @ignore)} split(/\s*,\s*/, $2);
		for my $p (@parents) {
		    # Is parent type actually an interface?  Use
		    # common-stuff struct instead:
		    if($p ~~ @interfaces) {
			$p = lcfirst($p) . "Stuff"
		    }
		    $children{$p} ||= [];
		    push(@{$children{$p}}, $name);
		}
	    }
	}
	# Does this declare properties?
	elsif(/^\s*(\w+):\s*(.*?)\s*;/) {
	    my($field, $ftype, $pfx, $json) = (ucfirst($1), $2, "", $1);
	    next if $ftype =~ /\"/;  # Ignore Type constants
	    $pfx = "[]" if $ftype =~ s/\[\s*(.*?)\s*\]/$1/;
	    $ftype =~ s/\s*\|\s*null\s*//;
	    given($ftype) {
		# Use Go types for corresponding JS types:
		when(/^boolean$/) { $ftype = "bool"; }
		when(/^string$/) { $ftype = "string"; }
		when(/^number$/) { $ftype = "int"; } # line/col/position only

		default {
		    # Interfaces get special treatment:
		    if($ftype ~~ @interfaces) {
			if($pfx) {
			    $pfx = "";
			    $ftype .= "s"
			}
		    }
		    # Patch certain entries as required:
		    if(exists $patches{"$type.$field"}) {
			$ftype = $patches{"$type.$field"};
		    }
		    # It's a pointer:
		    $ftype = "*$_" 
		}
	    }
	    push @fields,
		[$field, $pfx . $ftype, "json:\"$json\,omitempty\""];
	}
	else {
	    warn("Ignoring: ", $_) unless /^```|^}/;
	}
    }
    elsif($_ !~ /^$/ && !/^#/) {
	# Discussion?  Save as comment.
	s/^A(?=n? )/$type is a/;
     	s/`//g;
	$comments .= "//\n" if $comments;
	$comments .= wrap("// ", "// ", $_);
    }

    # Start of next section or net declaration; generate code & reset:
    if(/^#|^```js/ && $name) {
	if($name ~~ @ignore) {
	    warn "Ignoring: whole declaration of $name\n";
	}
	else {
	    print "/" . ("*" x 68) . "/\n\n";
	    print $comments;
	    print "struct $type {\n";
	    foreach my $p (@parents) {
		print "\t$p\n"
	    }
	    foreach my $f (@fields) {
		print "\t", $$f[0], "\t", $$f[1];
		print "\t`", $$f[2], "`" if $$f[2];
		print "\n";
	    }
	    print "}\n\n";
	    
	    # print "func ($type) Type() {\n";
	    # print "\treturn \"$name\"\n";
	    # print "}\n\n";
	}
	
	$type = $name = $comments = "";
	@fields = @parents = ();
    }
}

$Data::Dumper::Sortkeys = 1;
print "// $_" foreach split(/^/mg, Dumper(\%children));
